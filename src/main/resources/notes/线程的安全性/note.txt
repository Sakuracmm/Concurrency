JAVA内存模型 - 同步的八种操作
    1、lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态；
    2、unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，
                        释放后的变量才可以被其他线程锁定；
    3、read（读取）：作用于主内存的变量，把一个变量值从主内存传输到线程的工作
                        内存中，以便随后的load动作使用；
    4、load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量放入
                        到工作内存的变量副本中；
    5、use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
    6、assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给
                        工作内存的变量
    7、store（存储）：作用于工作内存的变量，把工作内存总的一个变量的值传送到主内
                        存中，以便随后的write的操作
    8、write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传
                        送到主内存的变量中

JAVA内存模型 - 同步规则
    1、如果要把一个变量从主内存中复制到工作内存，就需要按顺序地执行read和load操作，
        如果把变量从工作内存中同步回主内存中，就需要按顺序地执行store和write操作。
        但JAVA内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行的；
    2、不允许read和load、store和write操作之一单独出现；
    3、不允许一个线程丢弃它的最近assign操作，即变量在工作内存中改变了之后必须同步
        到主内存中；
    4、不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主
        内存中；
    5、一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化
        （load或assign）的变量。即就是对一个变量实施use和store之前，必须先执行过了
         assign和load操作；
    6、一个变量在同一时刻只允许一条线程对其进行lock操作，但是lock操作可以被同一条
        线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被
        解锁。lock和unlock必须成对出现；
    7、如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个
        变量之前需要重新执行load或assign操作初始化变量的值；
    8、如果一个变量事先没有被lock锁定，则不允许对它执行unlock操作；也不允许去unlock
        一个被其他线程锁定的变量；
    9、对一个变量执行unlock之前，必须先把此变量同步到主内存中（执行store和write操作）。

       -read->                              -load->                -Use->
 lock                                       《===》       工作内存   <===>  Java线程
主内存         《=====》     Save/Load      《===》       工作内存   <===>  Java线程
 unlock                                     《===》       工作内存   <===>  Java线程
       <-Write-                             <-store-               <-assign-


并发的优势与风险
    优势
        1、速度
           同时处理多个请求，响应更快；复杂的操作可以分成多个进程
        2、设计
            程序设计在某些情况下更简单，也可以有更多选择
        3、资源利用
            CPU能够在等待IO的时候做一些其他的事情
    风险
        1、安全性
            多个线程共享数据时可能会产生与期望不相符的结果
        2、活跃性
            某个操作无法继续进行下去时，就会发生活跃性问题，比如死锁，饥饿等问题
        3、 性能
            线程过多会使得：CPU频繁切换，调度事件增多；同步机制；消耗更多内存

并发模拟
    Postman:Http请求模拟工具
    Apache Bench（AB）:Apache附带的工具，测试网站性能
    JMeter：Apache阻止开发的压力测试工具
    代码：Semaphore、CountDownLatch等



